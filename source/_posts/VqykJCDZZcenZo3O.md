---
title: Java并发(1) - volatile
tags:
  - 并发
categories: Java
updated: 1636271387000
date: 2021-11-07 15:50:26
---

### JAVA内存模型

![IZ6xs0.png](https://z3.ax1x.com/2021/11/04/IZ6xs0.png)

Java 内存模型规定了所有的变量都存储在主内存中。每条线程有自己的工作内存，线程的工作内存保存了被该线程所使用到的变量（从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成
<!-- more -->

### volatile特性


#### 可见性

> 一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的

如果对声明了 volatile 变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据。但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了 volatile 变量都是从主内存中获取最新的


#### 禁止重排序

> 重排序是指处理器为了提高程序运行效率,可能会输入代码进行优化,可能会使执行顺序有所改变,但最终的结果会是一样的

禁止指令重排序的意义:
- 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行。
- 在进行指令优化时，不能将在对 volatile 变量的读操作或者写操作的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行

```java
//x,y 为普通变量,volflag 被 volatile 修饰
x = 10;          //语句1
y = 3;           //语句2
volflag = true;  //语句3
x= 5;           //语句4
y = 9;           //语句5
```

代码思路:
- volflag被volatile修饰，所以语句3不会被重排到语句1、语句2前面，也不会被重排到语句4、语句5 的后面
- 语句1、2 和语句4、5 的顺序是不能保证的
- volatile可以保证在执行到语句3的时候语句1、2是执行完毕的，语句4、5是没有执行的，并且语句1、2的执行结果对语句4、5是可见的


#### 为什么不能保证一致性

> 一致性要满足三个条件：原子性，有序性，可见性

-   原子性：即一个操作或者多个操作要么全部执行且执行的过程不会被任何因素打断，要么就都不执行。
-   可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
-   有序性：即程序执行的顺序按照代码的先后顺序执行

volatile 变量是比锁弱一级的同步机制。当一个线程获取锁之后，别的线程就不能对其进行读写，但是声明一个 volatile 变量只会让该线程对该变量的任何修改对其他线程可见,所以不能保证原子性


### 应用

单例模式中的 double check:
```java
class Singleton{    
   private volatile static Singleton instance = null;    
   private Singleton() {} 
      
   public static Singleton getInstance() {        
      if(instance == null) {            
           synchronized (Singleton.class) {                
             if(instance == null)
                    instance = new Singleton();
            }
        }        
       return instance;
    }
}
```

### 实现机制

```java
// 可以看到加入volatile关键字时，汇编后会多出一个lock前缀指令
Java代码: instance = new Singleton();//instance是volatile变量
汇编代码:  0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0,(%esp);
```

Lock前缀指令实际上相当于一个内存屏障（也称内存围栏）,其作用如下:
- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成
- 强制将对缓存的修改操作立即写入主内存
- 如果是写操作，它会导致其他CPU中对应的缓存行无效


### 实现原理

- 可见性
	- volatile 修饰的共享变量的写操作会触发“嗅探”，让处理器本地缓存中的 volatile 变量失效
	- 声明了 volatile 的变量进行写操作时，JVM 会向处理器发送一条 Lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。这一步确保了如果有其他线程对声明了 volatile 变量进行修改，则立即更新主内存中数据
- 有序性
	- 内存屏障的作用